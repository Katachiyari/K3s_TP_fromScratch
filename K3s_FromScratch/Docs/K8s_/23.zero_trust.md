ğŸ” Zero Trust Kubernetes â€” Mise en Å“uvre complÃ¨te et rÃ©elle

> ğŸ¯ Objectif
Transformer un cluster Kubernetes ouvert par dÃ©faut en un cluster strictement contrÃ´lÃ©, oÃ¹ chaque flux est explicitement autorisÃ©.




---

ğŸ§  1. Principe Zero Trust (adaptÃ© Ã  Kubernetes)

> Ne jamais faire confiance, toujours vÃ©rifier.



ConcrÃ¨tement dans Kubernetes :

âŒ Aucun Pod ne peut parler Ã  un autre par dÃ©faut

âŒ Aucun utilisateur nâ€™a de droits implicites

âŒ Aucun namespace nâ€™est â€œouvertâ€

âœ… Tout accÃ¨s est explicitement autorisÃ©

âœ… Tout est traÃ§able, auditable, rÃ©versible



---

ğŸ§± 2. Le point clÃ© que beaucoup ratent

âš ï¸ Kubernetes est OPEN par dÃ©faut

Sans configuration :

Tous les Pods peuvent communiquer entre eux

Tous les namespaces sont interconnectÃ©s

Aucun filtrage rÃ©seau interne


ğŸ‘‰ Zero Trust = casser ce modÃ¨le par dÃ©faut


---

ğŸ” 3. Les 4 piliers Zero Trust Kubernetes

Pilier	ImplÃ©mentation Kubernetes

IdentitÃ©	ServiceAccount
Autorisation	RBAC
RÃ©seau	NetworkPolicies
Runtime	SecurityContext


ğŸ‘‰ On va les appliquer dans cet ordre, car ils se complÃ¨tent.


---

ğŸ§© PILIER 1 â€” IdentitÃ© : ServiceAccount (obligatoire)

âŒ Mauvaise pratique (par dÃ©faut)

Les Pods utilisent le ServiceAccount default.

ğŸ‘‰ Tous les Pods partagent la mÃªme identitÃ©.


---

âœ… Bonne pratique Zero Trust

3.1 CrÃ©er un ServiceAccount dÃ©diÃ©

apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-sa
  namespace: prod

3.2 Lâ€™utiliser dans un Pod / Deployment

spec:
  serviceAccountName: app-sa

ğŸ“Œ Chaque application = une identitÃ© distincte


---

ğŸ§© PILIER 2 â€” Autorisation : RBAC strict

ğŸ¯ Objectif

Limiter exactement ce que lâ€™application peut faire via lâ€™API Kubernetes.


---

4.1 Exemple : lecture des ConfigMaps uniquement

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-read-config
  namespace: prod
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get"]


---

4.2 Associer le Role au ServiceAccount

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-rb
  namespace: prod
subjects:
- kind: ServiceAccount
  name: app-sa
roleRef:
  kind: Role
  name: app-read-config
  apiGroup: rbac.authorization.k8s.io

ğŸ“Œ Lâ€™application ne peut plus rien faire dâ€™autre.


---

ğŸ§© PILIER 3 â€” RÃ©seau : NetworkPolicies (cÅ“ur du Zero Trust)

âš ï¸ RÃ¨gle fondamentale

> La premiÃ¨re NetworkPolicy dâ€™un namespace bloque TOUT.




---

5.1 Politique par dÃ©faut : DENY ALL

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: prod
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress

ğŸ¯ RÃ©sultat :

âŒ Aucun Pod ne peut recevoir du trafic

âŒ Aucun Pod ne peut sortir


ğŸ‘‰ Namespace totalement verrouillÃ©


---

5.2 Autoriser le trafic interne de lâ€™application

Exemple : App â†’ DB

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-app-to-db
  namespace: prod
spec:
  podSelector:
    matchLabels:
      app: db
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api
    ports:
    - protocol: TCP
      port: 3306

ğŸ“Œ Lecture claire :

seuls les Pods app=api

peuvent parler aux Pods app=db

uniquement sur le port 3306



---

5.3 Autoriser lâ€™entrÃ©e depuis lâ€™Ingress

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-to-app
  namespace: prod
spec:
  podSelector:
    matchLabels:
      app: api
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80

ğŸ‘‰ Sans cette rÃ¨gle : Ingress = timeout.


---

5.4 Autoriser la sortie DNS (OBLIGATOIRE)

ğŸš¨ Oubli frÃ©quent â†’ cluster â€œcassÃ©â€

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: prod
spec:
  podSelector: {}
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53

ğŸ“Œ Sans DNS â†’ aucun Service ne fonctionne.


---

ğŸ§© PILIER 4 â€” SÃ©curitÃ© runtime (Pod Security)

6.1 SecurityContext strict

securityContext:
  runAsNonRoot: true
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false


---

6.2 Capabilities minimales

capabilities:
  drop:
    - ALL

ğŸ‘‰ Lâ€™application ne peut plus faire autre chose que ce quâ€™elle doit faire.


---

ğŸ§  7. Ce que Zero Trust change concrÃ¨tement

Avant	AprÃ¨s

RÃ©seau plat	RÃ©seau cloisonnÃ©
Pods bavards	Flux contrÃ´lÃ©s
AccÃ¨s implicite	AccÃ¨s explicite
Attaque latÃ©rale facile	Mouvement bloquÃ©
Debug flou	Audit clair



---

ğŸ§¯ 8. Erreurs classiques (rÃ©elles)

Erreur	SymptÃ´me

Oubli DNS	Services injoignables
Oubli Ingress	Timeout HTTP
Labels incohÃ©rents	Policy inefficace
RBAC trop large	Faille sÃ©curitÃ©



---

ğŸ“Œ SYNTHÃˆSE ULTIME

> Zero Trust Kubernetes =
RBAC strict
NetworkPolicies systÃ©matiques
IdentitÃ©s sÃ©parÃ©es
Pods durcis



ğŸ‘‰ Kubernetes devient alors une plateforme de production sÃ©curisÃ©e, pas un simple orchestrateur.


---

ğŸ”œ Suite logique (sans changer de niveau)

ğŸ‘‰ ğŸ“¦ Helm + GitOps avancÃ©
(zÃ©ro trust + dÃ©ploiements versionnÃ©s + rollback propre)
