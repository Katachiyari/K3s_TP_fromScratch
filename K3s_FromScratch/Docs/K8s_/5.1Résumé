Tu as 100 % raison ğŸ‘
ğŸ‘‰ Ce fichier nâ€™est PAS du Markdown valide, mÃªme sâ€™il ressemble visuellement Ã  de la doc.

Je vais faire 3 choses trÃ¨s clairement :

1. âŒ Tâ€™expliquer pourquoi GitHub ne le rend pas correctement


2. âœ… Tâ€™expliquer les rÃ¨gles Markdown que tu enfreins


3. âœ… Te donner la version Markdown CORRECTE, prÃªte Ã  coller sur GitHub




---

âŒ Pourquoi ce fichier nâ€™est PAS du Markdown

GitHub (CommonMark) nâ€™interprÃ¨te pas :

1ï¸âƒ£ Les titres sans #

Exemple incorrect :

â˜¸ï¸ Chapitre 1 â€” Introduction Ã  Kubernetes

â¡ï¸ GitHub voit Ã§a comme du texte normal, pas un titre.


---

2ï¸âƒ£ Les sÃ©parateurs --- utilisÃ©s nâ€™importe oÃ¹

--- est valide seulement :

aprÃ¨s une ligne vide

et hors bloc de code


Sinon âœ rendu incohÃ©rent.


---

3ï¸âƒ£ Les tableaux Ã©crits â€œen texteâ€

Exemple incorrect :

Ã‰lÃ©ment RÃ´le
Control Plane   Orchestration
Workers ExÃ©cution des Pods

â¡ï¸ Ce nâ€™est PAS un tableau Markdown.


---

4ï¸âƒ£ Le YAML sans bloc de code

Exemple incorrect :

apiVersion: apps/v1
kind: Deployment

â¡ï¸ GitHub lâ€™affiche comme du texte plat.


---

5ï¸âƒ£ Les commandes shell sans ```bash

MÃªme problÃ¨me pour kubectl apply.


---

âœ… RÃ¨gles Markdown GitHub Ã  respecter (rÃ©sumÃ©)

Ã‰lÃ©ment	RÃ¨gle

Titre	#, ##, ###
SÃ©parateur	--- entourÃ© de lignes vides
Tableau	`
Code	```lang
YAML	```yaml
Commandes	```bash



---

âœ… VERSION MARKDOWN CORRECTE (GitHub-ready)

ğŸ‘‰ Tu peux copier-coller TEL QUEL dans ton .md

# ğŸ§  RÃ©sumÃ© pÃ©dagogique â€” Chapitres 1 Ã  5 Kubernetes (Upstream)

---

## â˜¸ï¸ Chapitre 1 â€” Introduction Ã  Kubernetes

Kubernetes est une plateforme dâ€™orchestration de conteneurs permettant :

- DÃ©ploiement dâ€™applications conteneurisÃ©es
- Haute disponibilitÃ©
- ScalabilitÃ© automatique
- Auto-rÃ©paration
- Gestion du rÃ©seau et du stockage

ğŸ‘‰ Kubernetes gÃ¨re **lâ€™Ã©tat dÃ©sirÃ©** de lâ€™infrastructure applicative.

---

## ğŸ—ï¸ Chapitre 2 â€” Installation dâ€™un cluster Kubernetes

Un cluster Kubernetes se compose de :

| Ã‰lÃ©ment        | RÃ´le                         |
|---------------|------------------------------|
| Control Plane | Orchestration                |
| Workers       | ExÃ©cution des Pods           |
| etcd          | Base de donnÃ©es du cluster   |
| CNI           | RÃ©seau des Pods              |

### Installation standard (kubeadm)

1. Installer le runtime de conteneurs (containerd)
2. Installer `kubelet`, `kubeadm`, `kubectl`
3. Initialiser le cluster
4. Installer un plugin rÃ©seau (CNI)
5. Ajouter les workers

---

## ğŸ“¦ Chapitre 3 â€” Pods et Deployments

| Objet        | RÃ´le                                  |
|-------------|----------------------------------------|
| Pod         | UnitÃ© dâ€™exÃ©cution                      |
| ReplicaSet  | Maintient le nombre de Pods            |
| Deployment  | Gestion complÃ¨te des applications      |

Un **Deployment** permet :

- la rÃ©plication
- les rolling updates
- le rollback
- lâ€™auto-healing

---

## ğŸŒ Chapitre 4 â€” Services (rÃ©seau interne)

Les Pods ont une IP Ã©phÃ©mÃ¨re â†’ on utilise un **Service**.

| Type          | Usage                    |
|---------------|--------------------------|
| ClusterIP     | Communication interne    |
| NodePort      | Exposition simple        |
| LoadBalancer  | Environnement cloud      |
| ExternalName  | Alias DNS                |

Un Service fournit :

- une IP stable
- un DNS interne
- du load balancing

---

## ğŸŒ Chapitre 5 â€” Ingress (exposition HTTP)

Lâ€™Ingress permet :

- le routage HTTP par host / path
- la terminaison TLS
- la mutualisation dâ€™une IP publique

### Architecture logique

Client â†’ Ingress Controller â†’ Service â†’ Pods

---

## ğŸ§ª Exemple minimal complet â€” DÃ©ployer et exposer une application

Nous utilisons les **3 objets minimum** :

1. Deployment  
2. Service  
3. Ingress  

---

### ğŸ“ 1ï¸âƒ£ `deployment.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo-web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: demo-web
  template:
    metadata:
      labels:
        app: demo-web
    spec:
      containers:
        - name: nginx
          image: nginx:latest
          ports:
            - containerPort: 80


---

ğŸ“ 2ï¸âƒ£ service.yaml

apiVersion: v1
kind: Service
metadata:
  name: demo-web-service
spec:
  selector:
    app: demo-web
  ports:
    - port: 80
      targetPort: 80
  type: ClusterIP


---

ğŸ“ 3ï¸âƒ£ ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-web-ingress
spec:
  rules:
    - host: demo.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: demo-web-service
                port:
                  number: 80


---

ğŸš€ DÃ©ploiement

kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f ingress.yaml


---

ğŸ” VÃ©rifications

kubectl get pods
kubectl get svc
kubectl get ingress


---

ğŸŒ Test

Ajouter dans /etc/hosts :

IP_INGRESS demo.local

Puis ouvrir :

http://demo.local


---

ğŸ¯ Conclusion pÃ©dagogique

Avec seulement 3 fichiers YAML, tu sais maintenant :

âœ… DÃ©ployer une application

âœ… Lui donner un accÃ¨s rÃ©seau stable

âœ… Lâ€™exposer en HTTP avec routage


ğŸ‘‰ Câ€™est le socle fondamental de Kubernetes.

---


