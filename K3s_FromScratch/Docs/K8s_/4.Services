ğŸ“˜ Cours Kubernetes (Upstream) â€” Chapitre 4

ğŸŒ RÃ©seau Kubernetes & objet Service

> ğŸ“Œ Sources cadrÃ©es : le livre ENI (fil conducteur)  + documentation officielle Kubernetes (Services, DNS, kube-proxy, Ingress, Endpoints/EndpointSlices). 




---

ğŸ¯ Objectifs pÃ©dagogiques

Ã€ la fin de ce chapitre, tu sais :

âœ… Pourquoi lâ€™IP dâ€™un Pod nâ€™est pas un endpoint fiable

âœ… Ce quâ€™apporte un Service (IP virtuelle + DNS + load-balancing L4)

âœ… Comment Kubernetes route le trafic (Endpoints / EndpointSlices + kube-proxy)

âœ… Choisir entre ClusterIP / NodePort / LoadBalancer / ExternalName

âœ… Tester, diagnostiquer et corriger (DNS, selectors, endpoints, ports)



---

ğŸ§  1) ModÃ¨le rÃ©seau Kubernetes (rappel crucial)

Kubernetes impose un modÃ¨le rÃ©seau â€œplatâ€ :

ğŸ§© Chaque Pod a sa propre IP

ğŸ” Les Pods peuvent Ãªtre recrÃ©Ã©s â†’ IP qui change

ğŸŒ La connectivitÃ© Podâ†”Pod est assurÃ©e par le CNI (plugin rÃ©seau)


ğŸ“Œ ConsÃ©quence : ne jamais dÃ©pendre dâ€™une IP de Pod pour consommer une app.


---

â“ 2) Pourquoi un Pod nâ€™est pas â€œexposableâ€ directement

Un Pod est Ã©phÃ©mÃ¨re :

crash â†’ recrÃ©ation

rescheduling â†’ changement de node

rolling update â†’ remplacement par dâ€™autres Pods


ğŸ‘‰ Il faut un point dâ€™entrÃ©e stable â†’ Service.


---

ğŸ”Œ 3) Service : dÃ©finition et rÃ´le exact

Un Service est un objet Kubernetes qui expose une application (un ou plusieurs Pods) derriÃ¨re :

ğŸ§· une IP virtuelle stable (ClusterIP)

ğŸ§­ un nom DNS stable

âš–ï¸ une rÃ©partition de charge L4 (TCP/UDP/SCTP)


Kubernetes : â€œA Service is a method for exposing a network application that is running as one or more Podsâ€¦â€ 


---

ğŸ§² 4) Le cÅ“ur du Service : labels + selector

Un Service ne cible pas â€œun pod par nomâ€. Il cible un ensemble de Pods via un selector :

spec:
  selector:
    app: api

â¡ï¸ Tout Pod portant app=api devient backend du Service.

âœ… Commandes utiles

kubectl get pods --show-labels
kubectl describe svc <service-name>


---

ğŸ“ 5) Endpoints vs EndpointSlices : qui reÃ§oit le trafic ?

Quand tu crÃ©es un Service, Kubernetes maintient la liste des backends via :

Endpoints (historique)

EndpointSlices (plus scalable) 


ğŸ” Voir la vÃ©ritÃ© terrain

kubectl get endpoints
kubectl get endpointslices -A

â¡ï¸ Si ton Service ne route rien, 80% du temps : Endpoints vides (selector incorrect, labels absents, pods non Ready).


---

ğŸš¦ 6) kube-proxy : comment le trafic est â€œmagiquementâ€ routÃ© ?

kube-proxy tourne sur chaque node et reflÃ¨te lâ€™Ã©tat Services + Endpoints en rÃ¨gles rÃ©seau (iptables / IPVS). 

ğŸ‘‰ Le Service est une abstraction ; la â€œmÃ©caniqueâ€ de routage est rÃ©alisÃ©e via ces rÃ¨gles kernel.


---

ğŸ§± 7) Les types de Service (choix dâ€™architecture)

ğŸŸ¦ A) ClusterIP (par dÃ©faut) â€” interne cluster

âœ… microservices internes

âœ… DB interne (avec prÃ©cautions)

âŒ pas accessible de lâ€™extÃ©rieur


Doc Service + ClusterIP 


---

ğŸŸ§ B) NodePort â€” expose un port sur chaque node

Accessible via NodeIP:NodePort

Simple pour lab / dÃ©pannage

Moins clean en prod (gestion ports, surface dâ€™expo)


RÃ©sumÃ© officiel (NodePort) 


---

ğŸŸ© C) LoadBalancer â€” cloud / LB externe

Provisionne un load balancer via intÃ©gration infra (cloud provider)

RecommandÃ© cÃ´tÃ© cloud managÃ©


Doc LB externe 


---

ğŸŸª D) ExternalName â€” alias DNS externe

Pas de proxy, juste un CNAME

Utile pour exposer une dÃ©pendance externe â€œcomme un serviceâ€


Doc Service (ExternalName) 


---

ğŸ§ª 8) Mise en application (TP guidÃ©) â€” â€œAPI + Clientâ€

> ğŸ“ Objectif : prouver DNS + Service + load-balancing



Ã‰tape 1 â€” Namespace

kubectl create ns demo-net

Ã‰tape 2 â€” DÃ©ployer une API (3 replicas)

kubectl -n demo-net create deploy api --image=nginx --replicas=3
kubectl -n demo-net label deploy api app=api

Ã‰tape 3 â€” CrÃ©er un Service ClusterIP

kubectl -n demo-net expose deploy api --port=80 --target-port=80 --name=api-svc

(kubectl expose est documentÃ© officiellement. )

Ã‰tape 4 â€” VÃ©rifier Service + Endpoints

kubectl -n demo-net get svc api-svc -o wide
kubectl -n demo-net get endpoints api-svc -o wide
kubectl -n demo-net get pods -l app=api -o wide

âœ… Tu dois voir des endpoints correspondant aux IP des Pods.


---

ğŸ§ª 9) Test DNS & connectivitÃ© (comme en prod)

Option A â€” CrÃ©er un â€œpod outilsâ€ et tester

kubectl -n demo-net run dnsutils --image=registry.k8s.io/e2e-test-images/jessie-dnsutils:1.3 --command -- sleep 3600
kubectl -n demo-net exec -it dnsutils -- nslookup api-svc
kubectl -n demo-net exec -it dnsutils -- curl -I http://api-svc

âš ï¸ PiÃ¨ge classique : namespace

Une requÃªte DNS sans namespace cherche dâ€™abord dans le namespace du pod. 
Ex :

kubectl -n demo-net exec -it dnsutils -- nslookup api-svc.demo-net

Doc DNS officielle 


---

ğŸ§© 10) DÃ©bogage : â€œmon Service ne marche pasâ€

âœ… Checklist â€œ5 commandesâ€

1. Pods prÃªts ?



kubectl -n demo-net get pods

2. Labels corrects ?



kubectl -n demo-net get pods --show-labels
kubectl -n demo-net describe svc api-svc

3. Endpoints prÃ©sents ?



kubectl -n demo-net get endpoints api-svc -o yaml

4. DNS OK ?



kubectl -n demo-net exec -it dnsutils -- nslookup api-svc

5. kube-proxy tourne ?



kubectl -n kube-system get pods | grep -i proxy


---

ğŸ§­ 11) Service vs Ingress (teaser chap. 5)

Service = L4 (TCP/UDP), point dâ€™accÃ¨s stable vers Pods

Ingress = L7 (HTTP/HTTPS), routage par host/path, TLS, etc. 


ğŸ‘‰ En pratique :

Ingress route vers un Service

Le Service route vers les Pods



---

ğŸ§± SchÃ©ma Mermaid (mental model)

flowchart LR
  Client[ğŸ§‘â€ğŸ’» Client (Pod)] -->|DNS: api-svc.demo-net| DNS[(ğŸ§  CoreDNS)]
  Client -->|TCP/80| SVC[ğŸ”Œ Service ClusterIP api-svc]
  SVC -->|Endpoints / EndpointSlices| P1[ğŸ“¦ Pod api-1]
  SVC -->|Load-balance L4| P2[ğŸ“¦ Pod api-2]
  SVC -->|Load-balance L4| P3[ğŸ“¦ Pod api-3]
  KP[ğŸ§° kube-proxy (iptables/IPVS)] -.programmes rules .-> SVC


---

âœ… RÃ©sumÃ© â€œÃ  coller en fin de coursâ€

ğŸ“¦ Pods : IP Ã©phÃ©mÃ¨res â†’ pas un endpoint stable

ğŸ”Œ Service : IP stable + DNS + LB L4 vers des Pods sÃ©lectionnÃ©s par labels 

ğŸ“ Endpoints/EndpointSlices : la liste rÃ©elle des backends 

ğŸ§° kube-proxy : installe les rÃ¨gles rÃ©seau (iptables/IPVS) 

ğŸŒ DNS interne : service.namespace.svc.cluster.local 



---

Si tu veux, je fais le Chapitre 5 (Ingress) dans le mÃªme niveau de profondeur, avec :
âœ… rÃ¨gles host/path, TLS, controller, diffÃ©rences NodePort/LB/Ingress, commandes de debug, et un TP complet.
