Parfait ğŸ‘ on continue strictement dans la continuitÃ© du livre + doc officielle, niveau production avancÃ©e.


---

ğŸ“˜ Cours Kubernetes (Upstream) â€” Chapitre 14

ğŸš¦ StratÃ©gies de dÃ©ploiement avancÃ©es


---

ğŸ¯ Objectifs pÃ©dagogiques

Ã€ la fin de ce chapitre, tu sauras :

Comprendre les diffÃ©rentes stratÃ©gies de dÃ©ploiement

Choisir la bonne stratÃ©gie selon le contexte

ImplÃ©menter ces stratÃ©gies avec Deployment, Service et Ingress

RÃ©duire le risque lors des mises en production



---

ğŸ§  1. Le problÃ¨me des mises Ã  jour en production

Mettre Ã  jour une application en production implique des risques :

indisponibilitÃ©

rÃ©gression fonctionnelle

impact utilisateur


ğŸ‘‰ Kubernetes fournit des mÃ©canismes natifs pour contrÃ´ler ces mises Ã  jour dans Kubernetes.


---

ğŸ” 2. Rolling Update (stratÃ©gie par dÃ©faut)

Principe

Les Pods sont remplacÃ©s progressivement.

Ancienne version â†“
Nouvelle version â†‘

Avantages

Pas (ou peu) dâ€™indisponibilitÃ©

Simple Ã  mettre en Å“uvre


InconvÃ©nients

Ancienne et nouvelle versions cohabitent

Risque si incompatibilitÃ© (DB, API)



---

âš™ï¸ Configuration Rolling Update

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1

ParamÃ¨tres clÃ©s

maxUnavailable : Pods indisponibles autorisÃ©s

maxSurge : Pods supplÃ©mentaires temporaires



---

ğŸ§ª Commandes utiles

kubectl rollout status deploy my-app
kubectl rollout history deploy my-app
kubectl rollout undo deploy my-app


---

ğŸ”µ 3. Blue / Green Deployment

Principe

Deux environnements identiques :

Blue â†’ version actuelle

Green â†’ nouvelle version


Le trafic est basculÃ© dâ€™un coup.


---

ğŸ§© ImplÃ©mentation Kubernetes

2 Deployments (blue / green)

1 Service

Changement du selector du Service


selector:
  version: green

Avantages

Rollback immÃ©diat

Pas de mÃ©lange de versions


InconvÃ©nients

Double consommation de ressources



---

ğŸŸ¡ 4. Canary Deployment

Principe

La nouvelle version reÃ§oit une petite partie du trafic.

90% â†’ v1
10% â†’ v2

Si tout va bien â†’ montÃ©e progressive.


---

ğŸ§© ImplÃ©mentation simple

2 Deployments (v1 / v2)

MÃªme Service

RÃ©partition basÃ©e sur le nombre de Pods


Exemple :

v1 : 9 replicas

v2 : 1 replica



---

âš ï¸ Limites natives Kubernetes

Kubernetes ne gÃ¨re pas :

le pourcentage exact de trafic HTTP

les rÃ¨gles complexes (headers, usersâ€¦)


ğŸ‘‰ Pour un Canary avancÃ© â†’ Ingress Controller / Service Mesh


---

ğŸ§  5. Choisir la bonne stratÃ©gie

Contexte	StratÃ©gie

Mise Ã  jour simple	Rolling Update
ZÃ©ro risque	Blue / Green
Tests progressifs	Canary
Microservices critiques	Canary + mÃ©triques



---

ğŸ§ª 6. Bonnes pratiques production

Bonne pratique	Pourquoi

Readiness Probes	Ã‰viter trafic prÃ©maturÃ©
Liveness Probes	DÃ©tection crash
Metrics	DÃ©cision Canary
Rollback automatisÃ©	RÃ©duction MTTR
GitOps	DÃ©ploiement contrÃ´lÃ©



---

ğŸ§© 7. RÃ´le de GitOps et Helm

Helm gÃ¨re les versions

GitOps orchestre les dÃ©ploiements

Les stratÃ©gies sont dÃ©crites dans Git


ğŸ‘‰ Pas de clics, pas de kubectl manuel


---

ğŸ“Œ RÃ©sumÃ© du chapitre

StratÃ©gie	Usage

Rolling Update	Standard
Blue / Green	ZÃ©ro risque
Canary	Validation progressive



---

ğŸ“ Ã€ retenir

> Une mise en production nâ€™est pas un Ã©vÃ©nement,
câ€™est un processus contrÃ´lÃ©.



Kubernetes fournit les briques,
lâ€™architecture et la discipline font le reste.


---

ğŸ”œ Chapitre suivant

ğŸ§­ Architecture GitOps avancÃ©e
â¡ï¸ Argo CD / Flux
â¡ï¸ RÃ©conciliation continue
